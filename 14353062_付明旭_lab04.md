#Lab04死锁
##实验流程及代码
1. 编写deadlock.java

	![deadlockjava.png](https://ooo.0o0.ooo/2016/11/11/58257f1b944d6.png)

2. 在windows环境下运行javac Deadlock.java
3. linux 系统Windows系统（把下面这段到记事本里，然后保存为.bat，然将批处理文件放在java程序（Deadlock.class）目录下

 	![202J}134X_Q3M2CC_U_T$CE.png](https://ooo.0o0.ooo/2016/11/11/58257d6e08e41.png)

4. 截图分析
##实验效果
在执行至39次时，发生了死锁，程序无法运行下去，如下：
![BFVN28VI$N8%GBE21R78(J6.png](https://ooo.0o0.ooo/2016/11/11/58257d6eb1418.png)
##死锁产生的条件
产生死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。

（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。

（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
##实验分析
在bat代码里面，java文件被要求运行100次，在运行java文件时，首先声明两个变量A a，和B b，之后建立线程，之后线程放入调度队列，开始等待至count=0，当线程执行时，执行run函数时，methodB函数执行a.last；methodA执行，执行b.last；上述执行 的两个函数之间存在时间差，在不断重复执行时，由于等待时间的不同，以及时间差的累积，最后导致当methodA执行时，methodB也要执行，都需要对方才能执行下去，最后导致死锁，造成如上结果。
##实验感想
关于死锁的相关知识在操作系统这门课上已经有一些了解，所以对代码的理解上面没有太大的困难。因此觉得本次的实验难度不是很大。完成起来也比较轻松。